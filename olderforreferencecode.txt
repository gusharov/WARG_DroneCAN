High Level Analyzer
# For more information and documentation, please go to https://support.saleae.com/extensions/high-level-analyzer-extensions

from saleae.analyzers import HighLevelAnalyzer, AnalyzerFrame, StringSetting, NumberSetting, ChoicesSetting
from pathlib import Path

import sys
import os
import re
from pathlib import Path

lib_path = str(Path(__file__).parent / "lib")
if lib_path not in sys.path:
    sys.path.append(lib_path)

def find_files_by_number(target_number):
    script_dir = os.path.dirname(os.path.realpath(__file__))
    root_dir = os.path.join(script_dir, 'dsdl_specs')
    matched_files = []
    pattern = re.compile(rf'^{target_number}\..+')

    for dirpath, _, filenames in os.walk(root_dir):
        for filename in filenames:
            if pattern.match(filename):
                matched_files.append(os.path.join(dirpath, filename))

    if not matched_files:
        return "whoops"
    filename = os.path.basename(matched_files[0])  
    parts = filename.split('.')  
    return parts[1]
#import crcmod
#import dronecan
#from dronecan.uavcan.equipment.gnss.Auxiliary import Auxiliary  # assuming this is the correct DSDL

#dsdl_dir = os.path.join(os.path.dirname(dronecan.__file__), "dsdl_specs/ardupilot")

#dronecan.load_dsdl( r"C:\Users\gregu\logic_analyzer\DroneCAN_HLA\lib\dronecan\dsdl_specs\ardupilot")


#node = uavcan.make_node('/dev/ttyACM0')

#crc16 = crcmod.mkCrcFun(
#    0x11021,     # This is 0x1021 with the high bit set for 16-bit CRC
#    initCrc=0xFFFF,
#    xorOut=0x0000,
#    rev=False
#)
#import crcmod   
def reverse_bits_16bit(x):
    result = 0
    for i in range(16):
        if (x >> i) & 1:
            result |= 1 << (15 - i)
    return result

# High level analyzers must subclass the HighLevelAnalyzer class.
class Hla(HighLevelAnalyzer):
    # List of settings that a user can set for this High Level Analyzer.
    #maybe include a way to check whether they want to see all the values like priority, simulation, etc.
    # An optional list of types this analyzer produces, providing a way to customize the way frames are displayed in Logic 2.
    result_types = {
    'Standard Message': {
        'format': 'Standard Msg, Priority: {{data.Priority}}, Src: {{data.Source_ID}}, Name: {{data.Name}}, TypeID: {{data.Message_Data}}'
    },
    'Request Message': {
        'format': 'Request Msg, Priority: {{data.Priority}}, Src: {{data.Source_ID}}, Dest: {{data.Destination_Node_ID}}, Name: {{data.Name}}, TypeID: {{data.Message_Data}}'
    },
    'Response Message': {
        'format': 'Response Msg, Priority: {{data.Priority}}, Src: {{data.Source_ID}}, Dest: {{data.Destination_Node_ID}}, Name: {{data.Name}}, TypeID: {{data.Message_Data}}'
    },
    'Anonymous Message': {
        'format': 'Anonymous Msg, Priority: {{data.Priority}}, Name: {{data.Name}}, TypeID: {{data.Message_Data}}, Discr: {{data.Discriminator}}'
    },
    'Unknown Message Type': {
        'format': 'Unknown Msg'
    },
    'Not Identifier': {
        'format': 'Not Identifier'
    },
    'Not Extended': {
        'format': 'Not Extended'
    },
    'Acknowledgement': {
        'format': 'Acknowledgement'
    },
    'CRC': {
        'format': 'CRC'
    },
    'Extended': {
        'format': 'Extended, Priority: {{data.Priority}}, Source Node ID: {{data.Source_ID}}'
    },
    'Ctrl':{
        'format': 'Control, Num of Bytes: {{data.numbytes}}'
    },
    'Data':{
        'format': 'Data'
    },
    'Msg':{
        'format': 'Control, Num of Bytes: {{data.numbytes}}'
    }
}
    
#focus on making code that where you can add all the data from the dsdl files, makea class and then read for that

    def __init__(self):
        '''
        Initialize HLA.

        Settings can be accessed using the same name used above.
        '''
        self.number_of_data_frames = None
        self.numb_msgs = None
        self.current_full_msg = None
        self.frame_start = None
        self.frame_end = None
        self.message_start = None
        self.message_end = None
        self.current_end = None
        self.last_message = True
        self.multi_message = None
        current_priority = None
        current_service = None
        current_message_data = None
        current_source_node_id = None
        current_destination_node_id = None
        current_value = None
        current_frame_start = None
        current_message_type = None
        current_discriminator = None
        accumulated_data = []


        

    def decode(self, frame: AnalyzerFrame):
        '''
        Process a frame from the input analyzer, and optionally return a single `AnalyzerFrame` or a list of `AnalyzerFrame`s.

        The type and data values in `frame` will depend on the input analyzer.
        '''
        print(frame.type)

        if frame.type == 'identifier_field':
            #print("checking if extended")
            if 'extended' in frame.data and frame.data['extended']:
                if(self.message_start and float(frame.start_time - self.message_start) > 0.0005):
                    self.message_start = frame.start_time
                if(self.last_message):
                    self.last_message = False
                self.frame_start = frame.start_time
                self.number_of_data_frames = 0
                print("passed extended")
                # If the frame is an extended identifier, return None to skip processing
                value = frame.data['identifier']
                
                #reads the first 5 bits of the identifier
                current_service = value >> 7 & 0x01       
                #reads the service not bit 
                current_source_node_id = value & 0x7F      
                current_priority = value >> 24 & 0x1F  
                #return AnalyzerFrame("Extended", frame.start_time, frame.end_time,{
                #    'Priority': current_priority,
                #    'Source_ID': current_source_node_id
                #})
                #reads the source node id, which is the last 7 bits of the identifier
                if not current_service and current_source_node_id:
                    current_message_data = value >> 8 & 0xFFFF
                    string = find_files_by_number(current_message_data)
                    current_message_type = 'Standard Message'

                    #return AnalyzerFrame(current_message_type, frame.start_time, frame.end_time, {
                    #    'Priority': current_priority,
                    #    'Source_ID': current_source_node_id,
                    #     'Name': string,
                    #    'Message_Data': current_message_data
                    #})
                
                elif current_service and current_source_node_id:
                    current_message_data = value >> 16 & 0xFF
                    current_destination_node_id = value >> 8 & 0x7F
                    string = find_files_by_number(current_message_data)
                    if value >> 15 & 0x01:
                        current_message_type = 'Request Message'

                    else:
                        current_message_type = 'Response Message'
                        
                    #return AnalyzerFrame(current_message_type, frame.start_time, frame.end_time, {
                    #    'Priority': current_priority,
                    #    'Source_ID': current_source_node_id,
                    #    'Destination_Node_ID': current_destination_node_id,
                    #    'Name':string,
                    #    'Message_Data': current_message_data
                    #    
                    #})
                
                elif not current_service and current_source_node_id == 0:
                    #reads the data type id, which is the next 7 bits after the service not bit
                    current_message_data = value >> 8 & 0x3
                    current_message_type = 'Anonymous Message'
                    current_discriminator = value >> 10 & 0x3FFF
                    string = find_files_by_number(current_message_data)
                    #return AnalyzerFrame(current_message_type, frame.start_time, frame.end_time, {
                    #    'Priority': current_priority,
                    #    'Message_Data': current_message_data,
                    #    'Name':string,
                    #    'Discriminator' : current_discriminator
                    #    
                    #})
                
                else: 
                    current_message_data = None
                    current_message_type = 'Unknown Message Type'
                    #return AnalyzerFrame(current_message_type, frame.start_time, frame.end_time)
            else:
                print("failed extended")
                #return AnalyzerFrame("Not Extended", frame.start_time, frame.end_time)
                    

        if frame.type == 'control_field':
            self.numb_msgs = frame.data['num_data_bytes']
            #return AnalyzerFrame('Ctrl', frame.start_time, frame.end_time, {
            #    'numbytes': frame.data['num_data_bytes']
            #})

        if frame.type == 'data_field':
            num = frame.data['data']
            self.number_of_data_frames = self.number_of_data_frames + 1
            if(self.number_of_data_frames == 8):
                if(int.from_bytes(num,"big") & 0b10000000):
                    self.message_start = self.frame_start
                elif(int.from_bytes(num,"big") & 0b1000000):
                    self.last_message = True
            elif(self.numb_msgs == self.number_of_data_frames):
                self.last_message = True
                    #return AnalyzerFrame('Full-Frame,',self.message_start,self.message_end)
            #return AnalyzerFrame('Data', frame.start_time, frame.end_time)

            #accumulated_data.extend(frame.data['data'])
            #this will be where some of the dbc and cantools stuff is
           



        if frame.type == 'crc_field':
            fn = 2
            #return AnalyzerFrame('CRC', frame.start_time, frame.end_time)
        if frame.type == 'ack_field':
            fn = 2
            if(self.last_message):
                self.multi_message = False
                return AnalyzerFrame('Full-Frame,',self.message_start, frame.end_time)

        #if frame.type == 'can_error':
            # If the frame type is not what we expect, return None to skip processing
            #return None
        #this is where you would actually decode shit
        # Return the data frame itself
        #return AnalyzerFrame('DroneCAN_msg', frame.start_time, frame.end_time, {
        #    'input_type': frame.type
        #})
        #return AnalyzerFrame("Not Identifier", frame.start_time, frame.end_time)
#def decode(self, frame):
#    payload = bytes(frame.data)
#    can_id = current_destination_node_id
#    if can_id == Auxiliary.FIXED_PORT_ID:
#        try:
#            msg = Auxiliary()
#            msg.unpack(payload)
#            values = {field: getattr(msg, field) for field in msg._fields}
#            return AnalyzerFrame('Msg', frame.start_time, frame.end_time, values.items())
#        except Exception as e: